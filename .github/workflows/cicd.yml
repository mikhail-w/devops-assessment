name: CI/CD Pipeline

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:

jobs:
  test:
    name: Test Application
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      # Frontend Tests
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: '**/package-lock.json'

      - name: Install frontend dependencies
        run: |
          cd frontend
          npm ci

      - name: Run frontend linting
        run: |
          cd frontend
          npm run lint
        continue-on-error: true

      # Backend Tests
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install backend dependencies
        run: |
          cd backend
          pip install -r requirements.txt

      - name: Run backend tests
        run: |
          cd backend
          python manage.py test
        env:
          DEBUG: 'True'
          DB_HOST: 'localhost'
          DB_NAME: 'test_db'
          DB_USER: 'postgres'
          DB_PASS: 'postgres'
          SECRET_KEY: 'test-key-for-ci'

  build:
    name: Build Docker Images
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to DockerHub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}

      - name: Build and push frontend image
        uses: docker/build-push-action@v4
        with:
          context: ./frontend
          push: true
          tags: ${{ secrets.DOCKER_HUB_USERNAME }}/pokedex-frontend:latest
          cache-from:
            type=registry,ref=${{ secrets.DOCKER_HUB_USERNAME
            }}/pokedex-frontend:buildcache
          cache-to:
            type=registry,ref=${{ secrets.DOCKER_HUB_USERNAME
            }}/pokedex-frontend:buildcache,mode=max

      - name: Build and push backend image
        uses: docker/build-push-action@v4
        with:
          context: ./backend
          push: true
          tags: ${{ secrets.DOCKER_HUB_USERNAME }}/pokedex-backend:latest
          cache-from:
            type=registry,ref=${{ secrets.DOCKER_HUB_USERNAME
            }}/pokedex-backend:buildcache
          cache-to:
            type=registry,ref=${{ secrets.DOCKER_HUB_USERNAME
            }}/pokedex-backend:buildcache,mode=max

  deploy:
    name: Deploy Infrastructure and Application
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Install AWS CLI
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: '1.4.6'

      - name: Create SSH Key File
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SERVER_SSH_KEY }}" > ~/.ssh/terraform-ec2
          chmod 600 ~/.ssh/terraform-ec2
          ssh-keygen -y -f ~/.ssh/terraform-ec2 > ~/.ssh/terraform-ec2.pub

      - name: Handle Existing Resources
        run: |
          # Get default VPC
          VPC_ID=$(aws ec2 describe-vpcs --filters "Name=isDefault,Values=true" --query "Vpcs[0].VpcId" --output text)
          echo "Using VPC: $VPC_ID"

          # Delete key pair if it exists
          if aws ec2 describe-key-pairs --key-names pokedex-app-key &> /dev/null; then
            echo "Deleting existing key pair 'pokedex-app-key'"
            aws ec2 delete-key-pair --key-name pokedex-app-key
          fi

          # Check for security group and delete if exists
          SG_ID=$(aws ec2 describe-security-groups --filters "Name=group-name,Values=pokedex-app-sg" "Name=vpc-id,Values=$VPC_ID" --query "SecurityGroups[0].GroupId" --output text)
          if [ "$SG_ID" != "None" ] && [ ! -z "$SG_ID" ]; then
            echo "Found existing security group '$SG_ID'"
            
            # Get any EC2 instances using this security group
            INSTANCES=$(aws ec2 describe-instances --filters "Name=instance.group-id,Values=$SG_ID" "Name=instance-state-name,Values=running" --query "Reservations[*].Instances[*].InstanceId" --output text)
            
            # Terminate instances if they exist
            if [ ! -z "$INSTANCES" ]; then
              echo "Terminating instances: $INSTANCES"
              aws ec2 terminate-instances --instance-ids $INSTANCES
              echo "Waiting for instances to terminate..."
              aws ec2 wait instance-terminated --instance-ids $INSTANCES
            fi
            
            # Now try to delete the security group
            echo "Attempting to delete security group $SG_ID"
            aws ec2 delete-security-group --group-id $SG_ID || echo "Could not delete security group, but will continue"
          fi
        continue-on-error: true

      - name: Terraform Init
        run: terraform init
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Terraform Apply
        id: terraform_apply
        run: |
          # Apply terraform configuration
          terraform apply -auto-approve

          # Get the server IP directly using terraform output command
          # This avoids the env command issue
          SERVER_IP=$(terraform output -raw instance_public_ip 2>/dev/null || echo "")

          # If Terraform output failed, fall back to AWS CLI
          if [ -z "$SERVER_IP" ] || [ "$SERVER_IP" == "None" ]; then
            echo "Could not get IP from Terraform output, falling back to AWS CLI"
            # Get IP address from AWS CLI
            SERVER_IP=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=pokedex-app" "Name=instance-state-name,Values=running" --query "Reservations[0].Instances[0].PublicIpAddress" --output text)
          fi

          # Set GitHub environment variables for later steps
          # This is different from creating a .env file for the application
          echo "SERVER_IP=$SERVER_IP" >> $GITHUB_ENV
          echo "APPLICATION_URL=http://$SERVER_IP" >> $GITHUB_ENV

          # Print for debugging
          echo "Using server IP: $SERVER_IP"
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_app_name: pokedex-app

      - name: Wait for instance to be ready
        run: |
          echo "Waiting for instance to be ready..."
          sleep 60

          # Try SSH connection with retries
          for i in {1..5}; do
            if ssh -i ~/.ssh/terraform-ec2 -o StrictHostKeyChecking=no -o ConnectTimeout=20 ubuntu@${{ env.SERVER_IP }} "echo SSH connection successful"; then
              echo "SSH connection successful"
              break
            fi
            echo "SSH connection attempt $i failed, waiting 20s..."
            sleep 20
            if [ $i -eq 5 ]; then
              echo "Warning: Could not establish SSH connection after 5 attempts"
            fi
          done

      - name: Prepare deployment files
        run: |
          # Create .env file for the application (not related to GitHub Actions env)
          cat > .env << EOF
          DB_USER=${{ secrets.DB_USER }}
          DB_PASS=${{ secrets.DB_PASS }}
          DB_NAME=${{ secrets.DB_NAME }}
          API_URL=http://${{ env.SERVER_IP }}:3000
          DJANGO_SECRET_KEY=${{ secrets.DJANGO_SECRET_KEY }}
          NODE_ENV=production
          DOCKER_HUB_USERNAME=${{ secrets.DOCKER_HUB_USERNAME }}
          EOF

          # Debug: verify contents were created correctly
          echo "Created .env file for application"

      - name: Deploy application
        run: |
          # Create directory on remote server
          ssh -i ~/.ssh/terraform-ec2 -o StrictHostKeyChecking=no ubuntu@${{ env.SERVER_IP }} "mkdir -p /home/ubuntu/pokedex-app"

          # Copy deployment files
          scp -i ~/.ssh/terraform-ec2 -o StrictHostKeyChecking=no docker-compose.yml .env ubuntu@${{ env.SERVER_IP }}:/home/ubuntu/pokedex-app/

          # Setup and run application
          ssh -i ~/.ssh/terraform-ec2 -o StrictHostKeyChecking=no ubuntu@${{ env.SERVER_IP }} "
            cd /home/ubuntu/pokedex-app
            
            # Install Docker if needed
            if ! command -v docker &> /dev/null; then
              echo 'Installing Docker...'
              sudo apt-get update
              sudo apt-get install -y apt-transport-https ca-certificates curl software-properties-common
              curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
              sudo add-apt-repository 'deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable'
              sudo apt-get update
              sudo apt-get install -y docker-ce docker-ce-cli containerd.io
            fi
            
            # Install Docker Compose if needed
            if ! command -v docker-compose &> /dev/null; then
              echo 'Installing Docker Compose...'
              sudo curl -L \"https://github.com/docker/compose/releases/download/v2.15.1/docker-compose-\$(uname -s)-\$(uname -m)\" -o /usr/local/bin/docker-compose
              sudo chmod +x /usr/local/bin/docker-compose
            fi
            
            # Pull and run containers
            echo 'Stopping any existing containers...'
            sudo docker-compose down || true
            
            echo 'Pulling latest images...'
            sudo docker-compose pull
            
            echo 'Starting containers...'
            sudo docker-compose up -d
            
            # Verify
            echo 'Running containers:'
            sudo docker ps
          "

      - name: Verify Deployment
        run: |
          echo "Application deployed to ${{ env.APPLICATION_URL }}"
          echo "Waiting 30 seconds for application to initialize..."
          sleep 30

          # Check if application is responding
          for i in {1..3}; do
            echo "Attempt $i: Checking if application is responding..."
            if curl -s --head --request GET ${{ env.APPLICATION_URL }} | grep "200\|301\|302" > /dev/null; then
              echo "Application is responding correctly!"
              exit 0
            else
              echo "Application not responding yet, waiting 10 seconds..."
              sleep 10
            fi
          done

          echo "Warning: Could not verify application is responding, but deployment completed"
        continue-on-error: true

      - name: Notification
        run: |
          echo "Deployment completed! Application available at ${{ env.APPLICATION_URL }}"
          echo "To check application status, SSH into the server:"
          echo "ssh -i your-key ubuntu@${{ env.SERVER_IP }}"
          echo "Then run: cd /home/ubuntu/pokedex-app && sudo docker-compose ps"
