name: Pokedex CI/CD Pipeline

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  FRONTEND_IMAGE_NAME: pokedex-frontend
  BACKEND_IMAGE_NAME: pokedex-backend
  DOCKER_REGISTRY: docker.io
  AWS_REGION: us-east-1

jobs:
  # 1. Test and Analyze Code
  test:
    name: Test Application
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      # Frontend Tests
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: '**/package-lock.json'

      - name: Install frontend dependencies
        run: |
          cd frontend
          npm ci

      - name: Run frontend linting
        run: |
          cd frontend
          npm run lint
        continue-on-error: true

      # Backend Tests
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install backend dependencies
        run: |
          cd backend
          pip install -r requirements.txt

      - name: Run backend tests
        run: |
          cd backend
          python manage.py test
        env:
          DEBUG: 'True'
          DB_HOST: 'localhost'
          DB_NAME: 'test_db'
          DB_USER: 'postgres'
          DB_PASS: 'postgres'
          SECRET_KEY: 'test-key-for-ci'

  # 2. Build Docker Images
  build:
    name: Build Docker Images
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to DockerHub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}

      - name: Build and push frontend image
        uses: docker/build-push-action@v4
        with:
          context: ./frontend
          push: true
          tags: ${{ secrets.DOCKER_HUB_USERNAME }}/pokedex-frontend:latest
          cache-from:
            type=registry,ref=${{ secrets.DOCKER_HUB_USERNAME
            }}/pokedex-frontend:buildcache
          cache-to:
            type=registry,ref=${{ secrets.DOCKER_HUB_USERNAME
            }}/pokedex-frontend:buildcache,mode=max

      - name: Build and push backend image
        uses: docker/build-push-action@v4
        with:
          context: ./backend
          push: true
          tags: ${{ secrets.DOCKER_HUB_USERNAME }}/pokedex-backend:latest
          cache-from:
            type=registry,ref=${{ secrets.DOCKER_HUB_USERNAME
            }}/pokedex-backend:buildcache
          cache-to:
            type=registry,ref=${{ secrets.DOCKER_HUB_USERNAME
            }}/pokedex-backend:buildcache,mode=max

  # 3. Provision Infrastructure with Terraform
  provision-infrastructure:
    name: Provision Infrastructure
    needs: build
    runs-on: ubuntu-latest
    outputs:
      instance_ip: ${{ steps.extract-ip.outputs.instance_public_ip }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.7

      - name: Create SSH key for EC2
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/terraform-ec2
          chmod 600 ~/.ssh/terraform-ec2
          # Generate the public key from the private key
          ssh-keygen -y -f ~/.ssh/terraform-ec2 > ~/.ssh/terraform-ec2.pub

      # Delete existing resources that conflict with our Terraform configuration
      - name: Delete existing resources
        run: |
          echo "Attempting to delete existing resources that might conflict..."

          # Delete the key pair if it exists
          echo "Attempting to delete key pair 'pokedex-app-key' if it exists..."
          aws ec2 delete-key-pair --key-name pokedex-app-key --region ${{ env.AWS_REGION }} || true

          # Try to find and delete the security group if it exists
          echo "Looking for security group 'pokedex-app-sg'..."
          SG_ID=$(aws ec2 describe-security-groups --group-names pokedex-app-sg --query 'SecurityGroups[0].GroupId' --output text --region ${{ env.AWS_REGION }} 2>/dev/null || echo "")

          if [ ! -z "$SG_ID" ] && [ "$SG_ID" != "None" ]; then
            echo "Found security group $SG_ID, attempting to delete..."
            # Some security groups may have rules that need to be deleted first, or attached resources
            # We'll wait a bit to allow any dependencies to clear
            sleep 10
            aws ec2 delete-security-group --group-id $SG_ID --region ${{ env.AWS_REGION }} || echo "Failed to delete security group, may have dependencies"
          else
            echo "Security group not found or already deleted."
          fi

      - name: Terraform Init
        run: terraform init

      - name: Terraform Plan
        run: terraform plan -out=tfplan
        env:
          TF_VAR_instance_type: t2.micro
          TF_VAR_app_name: pokedex-app

      # Capture the terraform apply output to a file
      - name: Terraform Apply
        run: |
          terraform apply -auto-approve tfplan | tee terraform_apply_output.txt

      # Extract IP address directly from terraform apply output
      - name: Extract IP from Terraform output
        id: extract-ip
        run: |
          # Try to get the IP directly from terraform output command
          IP_ADDRESS=$(terraform output -raw instance_public_ip 2>/dev/null || echo "")

          if [ -z "$IP_ADDRESS" ]; then
            # Look for IP addresses in the terraform apply output
            IP_ADDRESS=$(grep -oE "instance_public_ip = \"[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+\"" terraform_apply_output.txt | grep -oE "[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+" || echo "")
          fi

          # If not found in the output, look in the terraform state
          if [ -z "$IP_ADDRESS" ]; then
            IP_ADDRESS=$(terraform state show aws_eip.app_eip | grep "public_ip" | grep -oE "[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+" | head -1 || echo "")
          fi

          # If still not found, query AWS directly
          if [ -z "$IP_ADDRESS" ]; then
            echo "Attempting to find instance by tag..."
            INSTANCE_ID=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=pokedex-app-server" --query "Reservations[0].Instances[0].InstanceId" --output text --region ${{ env.AWS_REGION }} || echo "")
            
            if [ -n "$INSTANCE_ID" ] && [ "$INSTANCE_ID" != "None" ]; then
              echo "Found instance ID: $INSTANCE_ID"
              IP_ADDRESS=$(aws ec2 describe-instances --instance-ids "$INSTANCE_ID" --query "Reservations[0].Instances[0].PublicIpAddress" --output text --region ${{ env.AWS_REGION }} || echo "")
              echo "Instance IP from AWS CLI: $IP_ADDRESS"
            fi
          fi

          # If we have an IP address, output it
          if [ -n "$IP_ADDRESS" ]; then
            echo "Found IP address: $IP_ADDRESS"
            echo "instance_public_ip=$IP_ADDRESS" >> $GITHUB_OUTPUT
          else
            echo "Failed to find instance IP address"
            exit 1
          fi
      - name: Wait for instance to be ready
        run: |
          echo "Waiting for instance to be ready..."
          sleep 60

  # 4. Deploy Application
  deploy-application:
    name: Deploy Application
    needs: provision-infrastructure
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ needs.provision-infrastructure.outputs.instance_ip }} >> ~/.ssh/known_hosts

      - name: Wait for SSH to be available
        run: |
          count=0
          max_attempts=10
          until ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no ubuntu@${{ needs.provision-infrastructure.outputs.instance_ip }} 'echo "SSH is up"' || [ $count -eq $max_attempts ]
          do
            echo "Waiting for SSH to be available... (attempt $count/$max_attempts)"
            sleep 15
            count=$((count+1))
          done

          if [ $count -eq $max_attempts ]; then
            echo "SSH failed to become available"
            exit 1
          fi

      - name: Create deployment directory
        run: |
          ssh -i ~/.ssh/id_rsa ubuntu@${{ needs.provision-infrastructure.outputs.instance_ip }} '
            mkdir -p ~/pokedex-app
          '

      - name: Copy docker-compose and configuration files
        run: |
          scp -i ~/.ssh/id_rsa docker-compose.yml ubuntu@${{ needs.provision-infrastructure.outputs.instance_ip }}:~/pokedex-app/
          scp -i ~/.ssh/id_rsa nginx.conf ubuntu@${{ needs.provision-infrastructure.outputs.instance_ip }}:~/pokedex-app/

          # Create .env file with secrets
          cat << EOF > .env
          DOCKER_HUB_USERNAME=${{ secrets.DOCKER_HUB_USERNAME }}
          DB_USER=${{ secrets.DB_USER }}
          DB_PASS=${{ secrets.DB_PASS }}
          DB_NAME=${{ secrets.DB_NAME }}
          DJANGO_SECRET_KEY=${{ secrets.DJANGO_SECRET_KEY }}
          API_URL=http://${{ needs.provision-infrastructure.outputs.instance_ip }}:3000
          NODE_ENV=production
          EOF

          # Copy .env file to server
          scp -i ~/.ssh/id_rsa .env ubuntu@${{ needs.provision-infrastructure.outputs.instance_ip }}:~/pokedex-app/

      - name: Deploy with Docker Compose
        run: |
          ssh -i ~/.ssh/id_rsa ubuntu@${{ needs.provision-infrastructure.outputs.instance_ip }} '
            cd ~/pokedex-app
            
            # Load environment variables
            set -a
            source .env
            set +a
            
            # Pull latest images
            docker-compose pull
            
            # Start containers
            docker-compose up -d
            
            # Clean up old images
            docker image prune -af
            
            # Check container status
            docker-compose ps
          '

  # 5. Health Check and Monitoring
  health-check:
    name: Health Check and Monitoring
    needs: [provision-infrastructure, deploy-application]
    runs-on: ubuntu-latest
    steps:
      - name: Check frontend availability
        uses: jtalk/url-health-check-action@v3
        with:
          url: http://${{ needs.provision-infrastructure.outputs.instance_ip }}
          max-attempts: 5
          retry-delay: 15s
        continue-on-error: true

      - name: Check backend API availability
        uses: jtalk/url-health-check-action@v3
        with:
          url:
            http://${{ needs.provision-infrastructure.outputs.instance_ip
            }}:3000/admin/
          max-attempts: 5
          retry-delay: 15s
        continue-on-error: true

      - name: Set up monitoring (optional)
        run: |
          echo "Setting up monitoring on the server..."
          ssh -i ~/.ssh/id_rsa ubuntu@${{ needs.provision-infrastructure.outputs.instance_ip }} '
            # Install monitoring tools
            sudo apt-get update
            sudo apt-get install -y prometheus-node-exporter
            
            # Start monitoring services
            sudo systemctl enable prometheus-node-exporter
            sudo systemctl start prometheus-node-exporter
          '
        continue-on-error: true

      - name: Update deployment status
        run: |
          echo "Deployment completed successfully!"
          echo "Application URL: http://${{ needs.provision-infrastructure.outputs.instance_ip }}"
          echo "Backend API URL: http://${{ needs.provision-infrastructure.outputs.instance_ip }}:3000"
