name: Pokedex CI/CD Pipeline

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  FRONTEND_IMAGE_NAME: pokedex-frontend
  BACKEND_IMAGE_NAME: pokedex-backend
  DOCKER_REGISTRY: docker.io
  AWS_REGION: us-east-1

jobs:
  # 1. Test and Analyze Code
  test:
    name: Test Application
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      # Frontend Tests
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: '**/package-lock.json'

      - name: Install frontend dependencies
        run: |
          cd frontend
          npm ci

      - name: Run frontend linting
        run: |
          cd frontend
          npm run lint
        continue-on-error: true

      # Backend Tests
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install backend dependencies
        run: |
          cd backend
          pip install -r requirements.txt

      - name: Run backend tests
        run: |
          cd backend
          python manage.py test
        env:
          DEBUG: 'True'
          DB_HOST: 'localhost'
          DB_NAME: 'test_db'
          DB_USER: 'postgres'
          DB_PASS: 'postgres'
          SECRET_KEY: 'test-key-for-ci'

  # 2. Build Docker Images
  build:
    name: Build Docker Images
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to DockerHub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}

      - name: Build and push frontend image
        uses: docker/build-push-action@v4
        with:
          context: ./frontend
          push: true
          tags: ${{ secrets.DOCKER_HUB_USERNAME }}/pokedex-frontend:latest
          cache-from:
            type=registry,ref=${{ secrets.DOCKER_HUB_USERNAME
            }}/pokedex-frontend:buildcache
          cache-to:
            type=registry,ref=${{ secrets.DOCKER_HUB_USERNAME
            }}/pokedex-frontend:buildcache,mode=max

      - name: Build and push backend image
        uses: docker/build-push-action@v4
        with:
          context: ./backend
          push: true
          tags: ${{ secrets.DOCKER_HUB_USERNAME }}/pokedex-backend:latest
          cache-from:
            type=registry,ref=${{ secrets.DOCKER_HUB_USERNAME
            }}/pokedex-backend:buildcache
          cache-to:
            type=registry,ref=${{ secrets.DOCKER_HUB_USERNAME
            }}/pokedex-backend:buildcache,mode=max

  # 3. Provision Infrastructure with Terraform
  provision-infrastructure:
    name: Provision Infrastructure
    needs: build
    runs-on: ubuntu-latest
    outputs:
      instance_ip: ${{ steps.extract-ip.outputs.instance_public_ip }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.7

      - name: Find Terraform directory
        id: find-terraform
        run: |
          TERRAFORM_DIR=$(find . -name "*.tf" -exec dirname {} \; | sort -u | head -1)
          if [ -z "$TERRAFORM_DIR" ]; then
            echo "No Terraform files found, using repository root"
            TERRAFORM_DIR="."
          fi
          echo "terraform_dir=$TERRAFORM_DIR" >> $GITHUB_OUTPUT
          echo "Found Terraform files in: $TERRAFORM_DIR"

      - name: Setup SSH key for Terraform
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/terraform-ec2
          chmod 600 ~/.ssh/terraform-ec2
          # Generate the public key from the private key
          ssh-keygen -y -f ~/.ssh/terraform-ec2 > ~/.ssh/terraform-ec2.pub

      # Check for existing resources
      - name: Check for existing resources
        run: |
          echo "Checking for existing resources that might conflict..."

          # Check if key pair exists before deleting
          KEY_EXISTS=$(aws ec2 describe-key-pairs --key-names pokedex-app-key --query 'KeyPairs[0].KeyName' --output text --region ${{ env.AWS_REGION }} 2>/dev/null || echo "NOT_FOUND")
          if [ "$KEY_EXISTS" != "NOT_FOUND" ]; then
            echo "Found existing key pair 'pokedex-app-key', deleting..."
            aws ec2 delete-key-pair --key-name pokedex-app-key --region ${{ env.AWS_REGION }}
          else
            echo "Key pair 'pokedex-app-key' not found."
          fi

          # Check for security group with better error handling
          SG_ID=$(aws ec2 describe-security-groups --filters "Name=group-name,Values=pokedex-app-sg" --query 'SecurityGroups[0].GroupId' --output text --region ${{ env.AWS_REGION }} 2>/dev/null || echo "NOT_FOUND")
          if [ "$SG_ID" != "NOT_FOUND" ] && [ "$SG_ID" != "None" ]; then
            echo "Found security group $SG_ID, checking for dependencies..."
            
            # Check for instances using this security group
            INSTANCES=$(aws ec2 describe-instances --filters "Name=instance.group-id,Values=$SG_ID" --query 'Reservations[*].Instances[*].InstanceId' --output text --region ${{ env.AWS_REGION }})
            if [ ! -z "$INSTANCES" ]; then
              echo "Security group is attached to instances: $INSTANCES. Will not delete to avoid disruption."
            else
              echo "No instances using this security group, attempting to delete..."
              aws ec2 delete-security-group --group-id $SG_ID --region ${{ env.AWS_REGION }} || echo "Failed to delete security group, may have dependencies"
            fi
          else
            echo "Security group 'pokedex-app-sg' not found or already deleted."
          fi

      - name: Terraform Init
        run: |
          cd ${{ steps.find-terraform.outputs.terraform_dir }}
          terraform init

      - name: Terraform Plan
        run: |
          cd ${{ steps.find-terraform.outputs.terraform_dir }}
          terraform plan -out=tfplan
        env:
          TF_VAR_instance_type: t2.micro
          TF_VAR_app_name: pokedex-app

      # Capture the terraform apply output to a file
      - name: Terraform Apply
        run: |
          cd ${{ steps.find-terraform.outputs.terraform_dir }}
          terraform apply -auto-approve tfplan | tee terraform_apply_output.txt

      # Extract IP with improved error handling
      - name: Extract IP from Terraform output
        id: extract-ip
        run: |
          cd ${{ steps.find-terraform.outputs.terraform_dir }}

          # Try to get IP from terraform output command
          echo "Trying to get IP from terraform output..."
          IP_ADDRESS=$(terraform output -raw instance_public_ip 2>/dev/null || echo "")

          # If not found in terraform output, try parsing the apply output
          if [ -z "$IP_ADDRESS" ]; then
            echo "Searching for IP in terraform_apply_output.txt..."
            if [ -f terraform_apply_output.txt ]; then
              IP_ADDRESS=$(grep -A 5 "Outputs:" terraform_apply_output.txt | grep "instance_public_ip" | grep -oE "[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+" || echo "")
            fi
          fi

          # If still not found, look in the terraform state
          if [ -z "$IP_ADDRESS" ]; then
            echo "Searching in terraform.tfstate file..."
            if [ -f terraform.tfstate ]; then
              IP_ADDRESS=$(grep -o '"public_ip": "[0-9]\+\.[0-9]\+\.[0-9]\+\.[0-9]\+"' terraform.tfstate | head -1 | grep -o '[0-9]\+\.[0-9]\+\.[0-9]\+\.[0-9]\+' || echo "")
            fi
          fi

          # If still not found, query AWS directly
          if [ -z "$IP_ADDRESS" ]; then
            echo "Attempting to find instance by tag..."
            INSTANCE_ID=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=pokedex-app-server" --query "Reservations[0].Instances[0].InstanceId" --output text --region ${{ env.AWS_REGION }} || echo "")
            
            if [ -n "$INSTANCE_ID" ] && [ "$INSTANCE_ID" != "None" ]; then
              echo "Found instance ID: $INSTANCE_ID"
              IP_ADDRESS=$(aws ec2 describe-instances --instance-ids "$INSTANCE_ID" --query "Reservations[0].Instances[0].PublicIpAddress" --output text --region ${{ env.AWS_REGION }} || echo "")
              echo "Instance IP from AWS CLI: $IP_ADDRESS"
            fi
          fi

          # Final validation to ensure IP is in correct format
          if [[ $IP_ADDRESS =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "Found valid IP address: $IP_ADDRESS"
            echo "instance_public_ip=$IP_ADDRESS" >> $GITHUB_OUTPUT
          else
            echo "Failed to obtain a valid IP address. Aborting deployment."
            exit 1
          fi

      - name: Wait for instance to be fully initialized
        run: |
          echo "Waiting for instance to be fully initialized..."
          sleep 120  # Increased wait time for better instance initialization

  # 4. Deploy Application
  deploy-application:
    name: Deploy Application
    needs: provision-infrastructure
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      # Set up SSH connection
      - name: Set up SSH connection
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ needs.provision-infrastructure.outputs.instance_ip }} >> ~/.ssh/known_hosts

      - name: Wait for SSH to be available
        run: |
          count=0
          max_attempts=15  # Increased max attempts
          echo "Waiting for SSH service to become available..."

          # Test SSH connection with timeout
          until timeout 15s ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o ConnectTimeout=5 ubuntu@${{ needs.provision-infrastructure.outputs.instance_ip }} 'echo "SSH is up"' || [ $count -eq $max_attempts ]
          do
            echo "Waiting for SSH to be available... (attempt $count/$max_attempts)"
            sleep 20  # Increased sleep time
            count=$((count+1))
          done

          if [ $count -eq $max_attempts ]; then
            echo "SSH failed to become available after multiple attempts"
            exit 1
          fi

      - name: Create deployment directory
        run: |
          ssh -i ~/.ssh/id_rsa ubuntu@${{ needs.provision-infrastructure.outputs.instance_ip }} '
            mkdir -p ~/pokedex-app
          '

      - name: Copy configuration files
        run: |
          # Find the existing files
          DOCKER_COMPOSE_PATH=$(find . -name "docker-compose.yml" | head -1)
          NGINX_CONF_PATH=$(find . -name "nginx.conf" | head -1)

          echo "Found docker-compose.yml at: $DOCKER_COMPOSE_PATH"
          echo "Found nginx.conf at: $NGINX_CONF_PATH"

          # Copy docker-compose file
          if [ -f "$DOCKER_COMPOSE_PATH" ]; then
            scp -i ~/.ssh/id_rsa "$DOCKER_COMPOSE_PATH" ubuntu@${{ needs.provision-infrastructure.outputs.instance_ip }}:~/pokedex-app/
          else
            echo "Error: docker-compose.yml file not found"
            exit 1
          fi

          # Copy nginx.conf file
          if [ -f "$NGINX_CONF_PATH" ]; then
            scp -i ~/.ssh/id_rsa "$NGINX_CONF_PATH" ubuntu@${{ needs.provision-infrastructure.outputs.instance_ip }}:~/pokedex-app/
          else
            echo "Error: nginx.conf file not found."
            exit 1
          fi

          # Create .env file with secrets
          - name: Prepare deployment files
          run: |
            # Create .env file for production
            cat > .env << EOF
            DB_USER=${{ secrets.DB_USER }}
            DB_PASS=${{ secrets.DB_PASS }}
            DB_NAME=${{ secrets.DB_NAME }}
            API_URL=http://${{ env.SERVER_IP }}:3000
            DJANGO_SECRET_KEY=${{ secrets.DJANGO_SECRET_KEY }}
            NODE_ENV=production
            DOCKER_HUB_USERNAME=${{ secrets.DOCKER_HUB_USERNAME }}
            EOF

          # Copy .env file to server
          scp -i ~/.ssh/id_rsa .env ubuntu@${{ needs.provision-infrastructure.outputs.instance_ip }}:~/pokedex-app/

      - name: Deploy with Docker Compose
        run: |
          ssh -i ~/.ssh/id_rsa ubuntu@${{ needs.provision-infrastructure.outputs.instance_ip }} '
            cd ~/pokedex-app
            
            # Load environment variables
            set -a
            source .env
            set +a
            
            # Ensure Docker is installed
            if ! command -v docker &> /dev/null; then
              echo "Docker not found, installing..."
              sudo apt-get update
              sudo apt-get install -y apt-transport-https ca-certificates curl software-properties-common
              curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
              sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
              sudo apt-get update
              sudo apt-get install -y docker-ce docker-ce-cli containerd.io
              sudo usermod -aG docker $USER
              # Using sudo for this session since group membership won't take effect until next login
              sudo docker --version
            fi
            
            # Ensure Docker Compose is installed
            if ! command -v docker-compose &> /dev/null; then
              echo "Docker Compose not found, installing..."
              sudo curl -L "https://github.com/docker/compose/releases/download/v2.20.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
              sudo chmod +x /usr/local/bin/docker-compose
              sudo docker-compose --version
            fi
            
            # Pull latest images
            sudo docker-compose pull
            
            # Start containers
            sudo docker-compose up -d
            
            # Clean up old images (but keep recent ones)
            sudo docker image prune -f --filter "until=24h"
            
            # Check container status
            sudo docker-compose ps
          '

  # 5. Health Check and Monitoring
  health-check:
    name: Health Check and Monitoring
    needs: [provision-infrastructure, deploy-application]
    runs-on: ubuntu-latest
    steps:
      - name: Check frontend availability
        id: frontend-health
        uses: jtalk/url-health-check-action@v3
        with:
          url: http://${{ needs.provision-infrastructure.outputs.instance_ip }}
          max-attempts: 8
          retry-delay: 20s
          follow-redirect: true

      - name: Check backend API availability
        id: backend-health
        uses: jtalk/url-health-check-action@v3
        with:
          url:
            http://${{ needs.provision-infrastructure.outputs.instance_ip
            }}:3000/admin/
          max-attempts: 8
          retry-delay: 20s
          follow-redirect: true

      - name: Set up monitoring
        run: |
          echo "Setting up monitoring on the server..."
          ssh -i ~/.ssh/id_rsa ubuntu@${{ needs.provision-infrastructure.outputs.instance_ip }} '
            # Check if node exporter is installed
            if ! command -v prometheus-node-exporter &> /dev/null; then
              # Install monitoring tools
              sudo apt-get update
              sudo apt-get install -y prometheus-node-exporter
              
              # Start monitoring services
              sudo systemctl enable prometheus-node-exporter
              sudo systemctl start prometheus-node-exporter
              
              echo "Monitoring tools installed and started"
            else
              echo "Monitoring tools already installed"
            fi
            
            # Verify monitoring service is running
            if systemctl is-active --quiet prometheus-node-exporter; then
              echo "Monitoring service is running"
            else
              echo "Monitoring service is not running, attempting to start..."
              sudo systemctl start prometheus-node-exporter
            fi
          '
        continue-on-error: true

      - name: Generate deployment report
        run: |
          echo "::set-output name=deployment_success::true"
          echo "Deployment completed successfully!"
          echo "Application URL: http://${{ needs.provision-infrastructure.outputs.instance_ip }}"
          echo "Backend API URL: http://${{ needs.provision-infrastructure.outputs.instance_ip }}:3000"
        if:
          steps.frontend-health.outcome == 'success' ||
          steps.backend-health.outcome == 'success'

      - name: Deployment failure notification
        run: |
          echo "::set-output name=deployment_success::false"
          echo "Deployment health checks failed!"
          echo "Please check the logs for more information."
          exit 1
        if:
          steps.frontend-health.outcome != 'success' &&
          steps.backend-health.outcome != 'success'
